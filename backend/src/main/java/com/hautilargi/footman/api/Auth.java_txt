package com.hautilargi.footman.api;


import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import jakarta.annotation.Resource.AuthenticationType;
import jakarta.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.*;ev+-
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;




/**
 * REST API for login/logout that issues JWT tokens.
 *
 * Notes:
 * - This controller expects Spring Security to be configured with an AuthenticationManager bean.
 * - JWT secret and expiration can be configured via application.properties:
 *      jwt.secret=your-secret
 *      jwt.expiration=3600000
 */
@RestController
@RequestMapping("/api/auth")
public class Auth {

    private final AuthenticationType authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final TokenBlacklist tokenBlacklist;

    @Autowired
    public Auth(AuthenticationType authenticationManager,
                JwtTokenProvider jwtTokenProvider,
                TokenBlacklist tokenBlacklist) {
        this.authenticationManager = authenticationManager;
        this.jwtTokenProvider = jwtTokenProvider;
        this.tokenBlacklist = tokenBlacklist;
    }

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@RequestBody LoginRequest req) {
        Authentication auth = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(req.getUsername(), req.getPassword()));
        SecurityContextHolder.getContext().setAuthentication(auth);

        List<String> roles = auth.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList());

        String token = jwtTokenProvider.createToken(req.getUsername(), roles);
        return ResponseEntity.ok(new LoginResponse(token));
    }

    @PostMapping("/logout")
    public ResponseEntity<?> logout(HttpServletRequest request) {
        String token = jwtTokenProvider.resolveToken(request);
        if (token != null && jwtTokenProvider.validateToken(token)) {
            Date exp = jwtTokenProvider.getExpiration(token);
            tokenBlacklist.revoke(token, exp);
        }
        SecurityContextHolder.clearContext();
        return ResponseEntity.ok().build();
    }

    // Optional endpoint to check token validity
    @GetMapping("/me")
    public ResponseEntity<?> me(HttpServletRequest request) {
        String token = jwtTokenProvider.resolveToken(request);
        if (token == null || !jwtTokenProvider.validateToken(token) || tokenBlacklist.isRevoked(token)) {
            return ResponseEntity.status(401).build();
        }
        Map<String, Object> info = new HashMap<>();
        info.put("username", jwtTokenProvider.getUsername(token));
        info.put("roles", jwtTokenProvider.getRoles(token));
        return ResponseEntity.ok(info);
    }
}

/* ===================== Helper components and DTOs ===================== */

@Component
class JwtTokenProvider {

    @Value("${jwt.secret:secret-key}")
    private String secretKey;

    @Value("${jwt.expiration:3600000}")
    private long validityInMilliseconds; // 1h default

    @jakarta.annotation.PostConstruct
    protected void init() {
        // ensure secret is base64-encoded for JJWT when using simple signing
        secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes());
    }

    public String createToken(String username, List<String> roles) {
        Claims claims = Jwts.claims().setSubject(username);
        claims.put("roles", roles);
        Date now = new Date();
        Date validity = new Date(now.getTime() + validityInMilliseconds);

        return Jwts.builder()
                .setClaims(claims)
                .setIssuedAt(now)
                .setExpiration(validity)
                .signWith(SignatureAlgorithm.HS256, secretKey)
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
            return true;
        } catch (Exception ex) {
            return false;
        }
    }

    public String resolveToken(HttpServletRequest req) {
        String bearer = req.getHeader("Authorization");
        if (bearer != null && bearer.startsWith("Bearer ")) {
            return bearer.substring(7);
        }
        return null;
    }

    public String getUsername(String token) {
        return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().getSubject();
    }

    @SuppressWarnings("unchecked")
    public List<String> getRoles(String token) {
        Object roles = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().get("roles");
        if (roles instanceof List) {
            return (List<String>) roles;
        }
        return Collections.emptyList();
    }

    public Date getExpiration(String token) {
        return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().getExpiration();
    }
}

@Component
class TokenBlacklist {
    // token -> expiration time
    private final Map<String, Date> revoked = new ConcurrentHashMap<>();

    public void revoke(String token, Date expiration) {
        if (token != null && expiration != null) {
            revoked.put(token, expiration);
        }
    }

    public boolean isRevoked(String token) {
        if (token == null) return false;
        Date exp = revoked.get(token);
        if (exp == null) return false;
        if (exp.before(new Date())) {
            revoked.remove(token);
            return false;
        }
        return true;
    }
}

class LoginRequest {
    private String username;
    private String password;

    public LoginRequest() {}

    public LoginRequest(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}

class LoginResponse {
    private String token;

    public LoginResponse() {}

    public LoginResponse(String token) { this.token = token; }

    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }
}